// llvm_backend.c - Complete LLVM Backend Implementation
#include "llvm_backend.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <llvm-c/Core.h>
#include <llvm-c/Target.h>
#include <llvm-c/Analysis.h>
#include <llvm-c/Transforms/Scalar.h>

// Forward declarations
static LLVMTypeRef semantic_type_to_llvm(LLVMBackend* backend, SemanticType type);
static void declare_printf(LLVMBackend* backend);
static void declare_scanf(LLVMBackend* backend);

// Global function declarations
static LLVMValueRef printf_func = NULL;
static LLVMValueRef scanf_func = NULL;

// Variable table for tracking variable allocations (dynamic)
static struct {
    char* name;
    LLVMValueRef alloca;
    SemanticType type;
} *variable_table = NULL;
static int variable_count = 0;
static int variable_capacity = 256;

// Temporary table for tracking temporary allocations and their types (dynamic)
static struct {
    LLVMValueRef alloca;
    SemanticType type;
    bool allocated;
} *temp_table = NULL;
static int temp_capacity = 1000;

// Initialize dynamic tables
static void init_dynamic_tables() {
    if (!variable_table) {
        variable_table = calloc(variable_capacity, sizeof(*variable_table));
    }
    if (!temp_table) {
        temp_table = calloc(temp_capacity, sizeof(*temp_table));
    }
}

// Expand variable table if needed
static void expand_variable_table() {
    if (variable_count >= variable_capacity) {
        int old_capacity = variable_capacity;
        variable_capacity *= 2;
        variable_table = realloc(variable_table, variable_capacity * sizeof(*variable_table));
        // Initialize new entries
        for (int i = old_capacity; i < variable_capacity; i++) {
            variable_table[i].name = NULL;
            variable_table[i].alloca = NULL;
            variable_table[i].type = TYPE_UNKNOWN;
        }
        printf("[LLVM Debug] Expanded variable table to %d entries\n", variable_capacity);
    }
}

// Expand temp table if needed  
static void expand_temp_table(int needed_size) {
    if (needed_size >= temp_capacity) {
        int old_capacity = temp_capacity;
        while (temp_capacity <= needed_size) {
            temp_capacity *= 2;
        }
        temp_table = realloc(temp_table, temp_capacity * sizeof(*temp_table));
        // Initialize new entries
        for (int i = old_capacity; i < temp_capacity; i++) {
            temp_table[i].alloca = NULL;
            temp_table[i].type = TYPE_UNKNOWN;
            temp_table[i].allocated = false;
        }
        printf("[LLVM Debug] Expanded temp table to %d entries\n", temp_capacity);
    }
}

// Find or create variable allocation
static LLVMValueRef get_or_create_variable(LLVMBackend* backend, const char* name, SemanticType type) {
    init_dynamic_tables();
    
    // First, try to find existing variable
    for (int i = 0; i < variable_count; i++) {
        if (variable_table[i].name && strcmp(variable_table[i].name, name) == 0) {
            return variable_table[i].alloca;
        }
    }
    
    // Create new variable allocation
    expand_variable_table();
    
    LLVMTypeRef llvm_type = semantic_type_to_llvm(backend, type);
    LLVMValueRef alloca = LLVMBuildAlloca(backend->builder, llvm_type, name);
    
    variable_table[variable_count].name = strdup(name);
    variable_table[variable_count].alloca = alloca;
    variable_table[variable_count].type = type;
    variable_count++;
    
    printf("[LLVM Debug] Created variable allocation for '%s' with type %d\n", name, type);
    return alloca;
}

// Create LLVM backend
LLVMBackend* create_llvm_backend(const char* module_name) {
    LLVMBackend* backend = malloc(sizeof(LLVMBackend));
    if (!backend) return NULL;
    
    // Initialize dynamic tables
    init_dynamic_tables();
    
    // Reset variable table
    variable_count = 0;
    for (int i = 0; i < variable_capacity; i++) {
        if (variable_table[i].name) {
            free(variable_table[i].name);
            variable_table[i].name = NULL;
        }
        variable_table[i].alloca = NULL;
        variable_table[i].type = TYPE_UNKNOWN;
    }
    
    // Reset temp table
    for (int i = 0; i < temp_capacity; i++) {
        temp_table[i].alloca = NULL;
        temp_table[i].type = TYPE_UNKNOWN;
        temp_table[i].allocated = false;
    }
    
    // Initialize LLVM
    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    
    // Create context and module
    backend->context = LLVMContextCreate();
    backend->module = LLVMModuleCreateWithNameInContext(module_name, backend->context);
    backend->builder = LLVMCreateBuilderInContext(backend->context);
    backend->target_machine = NULL;
    backend->variables = NULL;
    backend->functions = NULL;
    backend->var_count = 0;
    backend->func_count = 0;
    backend->target_triple = NULL;
    backend->is_32bit = false;
    
    return backend;
}

// Free LLVM backend with cleanup of dynamic tables
void free_llvm_backend(LLVMBackend* backend) {
    if (!backend) return;
    
    // Clean up variable table
    if (variable_table) {
        for (int i = 0; i < variable_count; i++) {
            if (variable_table[i].name) {
                free(variable_table[i].name);
            }
        }
        free(variable_table);
        variable_table = NULL;
        variable_count = 0;
        variable_capacity = 256;
    }
    
    // Clean up temp table
    if (temp_table) {
        free(temp_table);
        temp_table = NULL;
        temp_capacity = 1000;
    }
    
    if (backend->target_triple) free(backend->target_triple);
    if (backend->variables) free(backend->variables);
    if (backend->functions) free(backend->functions);
    if (backend->target_machine) LLVMDisposeTargetMachine(backend->target_machine);
    LLVMDisposeBuilder(backend->builder);
    LLVMDisposeModule(backend->module);
    LLVMContextDispose(backend->context);
    free(backend);
}

// Convert semantic type to LLVM type
static LLVMTypeRef semantic_type_to_llvm(LLVMBackend* backend, SemanticType type) {
    switch (type) {
        // Signed Integer Types
        case TYPE_I8:   return LLVMInt8TypeInContext(backend->context);
        case TYPE_I16:  return LLVMInt16TypeInContext(backend->context);
        case TYPE_I32:  return LLVMInt32TypeInContext(backend->context);
        case TYPE_I64:  return LLVMInt64TypeInContext(backend->context);
        
        // Unsigned Integer Types (same as signed in LLVM, signedness handled in operations)
        case TYPE_U8:   return LLVMInt8TypeInContext(backend->context);
        case TYPE_U16:  return LLVMInt16TypeInContext(backend->context);
        case TYPE_U32:  return LLVMInt32TypeInContext(backend->context);
        case TYPE_U64:  return LLVMInt64TypeInContext(backend->context);
        
        // Floating Point Types
        case TYPE_F8:   return LLVMInt8TypeInContext(backend->context);  // Custom 8-bit float as int8
        case TYPE_F16:  return LLVMHalfTypeInContext(backend->context);   // IEEE 754 half precision
        case TYPE_F32:  return LLVMFloatTypeInContext(backend->context);  // IEEE 754 single precision
        case TYPE_F64:  return LLVMDoubleTypeInContext(backend->context); // IEEE 754 double precision
        
        // Special Types
        case TYPE_NUM:  return LLVMDoubleTypeInContext(backend->context); // Dynamic numeric as double
        case TYPE_BOOL: return LLVMInt1TypeInContext(backend->context);   // 1-bit boolean
        case TYPE_CHAR: return LLVMInt8TypeInContext(backend->context);   // 8-bit character
        case TYPE_STR:  return LLVMPointerType(LLVMInt8TypeInContext(backend->context), 0); // char*
        case TYPE_VOID: return LLVMVoidTypeInContext(backend->context);   // void
        
        // Default/Error cases
        case TYPE_UNKNOWN:
        case TYPE_ERROR:
        default:        
            printf("[LLVM Warning] Unknown type %d, defaulting to i32\n", type);
            return LLVMInt32TypeInContext(backend->context);
    }
}

// Declare printf function
static void declare_printf(LLVMBackend* backend) {
    if (printf_func) return;
    
    // printf(format, ...) -> int
    LLVMTypeRef char_ptr = LLVMPointerType(LLVMInt8TypeInContext(backend->context), 0);
    LLVMTypeRef printf_type = LLVMFunctionType(
        LLVMInt32TypeInContext(backend->context),  // return int
        &char_ptr,                                 // first arg: char*
        1,                                         // one fixed arg
        1                                          // variadic
    );
    
    printf_func = LLVMAddFunction(backend->module, "printf", printf_type);
}

// Declare scanf function
static void declare_scanf(LLVMBackend* backend) {
    if (scanf_func) return;
    
    // scanf(format, ...) -> int
    LLVMTypeRef char_ptr = LLVMPointerType(LLVMInt8TypeInContext(backend->context), 0);
    LLVMTypeRef scanf_type = LLVMFunctionType(
        LLVMInt32TypeInContext(backend->context),  // return int
        &char_ptr,                                 // first arg: char*
        1,                                         // one fixed arg
        1                                          // variadic
    );
    
    scanf_func = LLVMAddFunction(backend->module, "scanf", scanf_type);
}

// Convert IR operand to LLVM value with type awareness
static LLVMValueRef operand_to_llvm_value(LLVMBackend* backend, IROperand* operand) {
    if (!operand) return NULL;
    
    switch (operand->type) {
        case OPERAND_CONST_INT: {
            SemanticType type = operand->data_type;
            LLVMTypeRef llvm_type = semantic_type_to_llvm(backend, type);
            
            // Handle different integer sizes and signedness
            if (type == TYPE_BOOL) {
                return LLVMConstInt(llvm_type, operand->value.int_val ? 1 : 0, 0);
            } else if (type == TYPE_CHAR || type == TYPE_I8 || type == TYPE_U8) {
                return LLVMConstInt(llvm_type, operand->value.int_val & 0xFF, 0);
            } else if (type == TYPE_I16 || type == TYPE_U16) {
                return LLVMConstInt(llvm_type, operand->value.int_val & 0xFFFF, 0);
            } else if (type == TYPE_I64 || type == TYPE_U64) {
                return LLVMConstInt(llvm_type, operand->value.int_val, 0);
            } else {
                // Default to 32-bit
                return LLVMConstInt(llvm_type, operand->value.int_val, 0);
            }
        }
                              
        case OPERAND_CONST_FLOAT: {
            SemanticType type = operand->data_type;
            LLVMTypeRef llvm_type = semantic_type_to_llvm(backend, type);
            
            if (type == TYPE_F16) {
                return LLVMConstReal(llvm_type, operand->value.float_val);
            } else if (type == TYPE_F32) {
                return LLVMConstReal(llvm_type, operand->value.float_val);
            } else if (type == TYPE_F64 || type == TYPE_NUM) {
                return LLVMConstReal(llvm_type, operand->value.float_val);
            } else if (type == TYPE_F8) {
                // Custom F8 handling - convert to i8
                uint8_t f8_val = (uint8_t)(operand->value.float_val * 15.0f); // Simple conversion
                return LLVMConstInt(llvm_type, f8_val, 0);
            } else {
                return LLVMConstReal(LLVMFloatTypeInContext(backend->context), operand->value.float_val);
            }
        }
                               
        case OPERAND_CONST_STR: {
            // For string constants, return the string pointer directly
            return LLVMBuildGlobalStringPtr(backend->builder, operand->value.str_val, "str");
        }
            
        case OPERAND_TEMP: {
            init_dynamic_tables();
            int temp_id = operand->value.temp_id;
            
            if (temp_id >= 0 && temp_id < temp_capacity && temp_table[temp_id].allocated) {
                LLVMValueRef temp_alloca = temp_table[temp_id].alloca;
                LLVMTypeRef load_type = semantic_type_to_llvm(backend, temp_table[temp_id].type);
                
                return LLVMBuildLoad2(backend->builder, load_type, temp_alloca, "temp_load");
            } else {
                printf("[LLVM Error] Invalid or unallocated temp_id %d in operand_to_llvm_value\n", temp_id);
                // Return a zero constant as fallback
                return LLVMConstInt(LLVMInt32TypeInContext(backend->context), 0, 0);
            }
        }
            
        case OPERAND_VAR: {
            // Look up variable in variable table
            if (operand->value.name) {
                init_dynamic_tables();
                for (int i = 0; i < variable_count; i++) {
                    if (variable_table[i].name && strcmp(variable_table[i].name, operand->value.name) == 0) {
                        LLVMTypeRef load_type = semantic_type_to_llvm(backend, variable_table[i].type);
                        return LLVMBuildLoad2(backend->builder, load_type, variable_table[i].alloca, "var_load");
                    }
                }
                printf("[LLVM Debug] Variable '%s' not found in table\n", operand->value.name);
            }
            return LLVMConstInt(LLVMInt32TypeInContext(backend->context), 0, 0);
        }
            
        case OPERAND_LABEL:
        case OPERAND_FUNCTION:
            // Handle separately
            break;
    }
    
    return LLVMConstInt(LLVMInt32TypeInContext(backend->context), 0, 0);
}

// Get or create temporary allocation with proper type
static LLVMValueRef get_or_create_temp(LLVMBackend* backend, int temp_id, SemanticType type) {
    init_dynamic_tables();
    expand_temp_table(temp_id);
    
    if (temp_table[temp_id].allocated && temp_table[temp_id].type == type) {
        return temp_table[temp_id].alloca;
    }
    
    // Create new allocation with the correct type
    LLVMTypeRef llvm_type = semantic_type_to_llvm(backend, type);
    LLVMValueRef alloca = LLVMBuildAlloca(backend->builder, llvm_type, "temp");
    
    temp_table[temp_id].alloca = alloca;
    temp_table[temp_id].type = type;
    temp_table[temp_id].allocated = true;
    
    printf("[LLVM Debug] Created temp%d allocation with type %d\n", temp_id, type);
    return alloca;
}

// Helper function to store values with type preservation
static void store_to_temp_typed(LLVMBackend* backend, LLVMValueRef value, 
                               int temp_id, SemanticType dest_type) {
    if (!value || temp_id < 0) {
        printf("[LLVM Error] Invalid parameters in store_to_temp_typed\n");
        return;
    }
    
    LLVMValueRef temp_alloca = get_or_create_temp(backend, temp_id, dest_type);
    if (!temp_alloca) {
        printf("[LLVM Error] Failed to get temp allocation for temp%d\n", temp_id);
        return;
    }
    
    LLVMTypeRef alloca_type = LLVMGetElementType(LLVMTypeOf(temp_alloca));
    LLVMTypeRef value_type = LLVMTypeOf(value);
    
    LLVMValueRef converted_value = value;
    
    // Only convert if types are different
    if (alloca_type != value_type) {
        // Handle type conversions based on destination type
        if (LLVMGetTypeKind(alloca_type) == LLVMIntegerTypeKind && 
            LLVMGetTypeKind(value_type) == LLVMIntegerTypeKind) {
            
            unsigned alloca_bits = LLVMGetIntTypeWidth(alloca_type);
            unsigned value_bits = LLVMGetIntTypeWidth(value_type);
            
            if (alloca_bits != value_bits) {
                if (alloca_bits < value_bits) {
                    // Truncate to smaller type
                    converted_value = LLVMBuildTrunc(backend->builder, value, alloca_type, "trunc");
                } else {
                    // Extend to larger type
                    converted_value = LLVMBuildSExt(backend->builder, value, alloca_type, "sext");
                }
            }
        }
        else if (LLVMGetTypeKind(alloca_type) == LLVMFloatTypeKind ||
                 LLVMGetTypeKind(alloca_type) == LLVMDoubleTypeKind ||
                 LLVMGetTypeKind(alloca_type) == LLVMHalfTypeKind) {
            
            if (LLVMGetTypeKind(value_type) == LLVMIntegerTypeKind) {
                // Convert integer to float
                converted_value = LLVMBuildSIToFP(backend->builder, value, alloca_type, "itof");
            } else if (LLVMGetTypeKind(value_type) == LLVMFloatTypeKind ||
                       LLVMGetTypeKind(value_type) == LLVMDoubleTypeKind ||
                       LLVMGetTypeKind(value_type) == LLVMHalfTypeKind) {
                // Float to float conversion if needed
                if (LLVMGetTypeKind(alloca_type) == LLVMDoubleTypeKind) {
                    converted_value = LLVMBuildFPExt(backend->builder, value, alloca_type, "fpext");
                } else {
                    converted_value = LLVMBuildFPTrunc(backend->builder, value, alloca_type, "fptrunc");
                }
            }
        }
        else if (LLVMGetTypeKind(alloca_type) == LLVMIntegerTypeKind &&
                 (LLVMGetTypeKind(value_type) == LLVMFloatTypeKind ||
                  LLVMGetTypeKind(value_type) == LLVMDoubleTypeKind ||
                  LLVMGetTypeKind(value_type) == LLVMHalfTypeKind)) {
            // Convert float to integer
            converted_value = LLVMBuildFPToSI(backend->builder, value, alloca_type, "ftoi");
        }
        else if (LLVMGetTypeKind(value_type) == LLVMPointerTypeKind) {
            // Keep pointers as-is or convert appropriately
            if (LLVMGetTypeKind(alloca_type) == LLVMIntegerTypeKind) {
                converted_value = LLVMBuildPtrToInt(backend->builder, value, alloca_type, "ptr_to_int");
            }
        }
    }
    
    LLVMBuildStore(backend->builder, converted_value, temp_alloca);
}

// Translate IR instruction to LLVM with type awareness
static void translate_ir_instruction(LLVMBackend* backend, IRInstruction* instr) {
    if (!instr) return;
    
    LLVMValueRef result = NULL;
    
    // Debug: Print IR instruction being processed
    printf("[LLVM Debug] Processing IR instruction: opcode=%d\n", instr->opcode);
    if (instr->dest) {
        printf("[LLVM Debug]   dest: type=%d\n", instr->dest->type);
    }
    if (instr->src1) {
        printf("[LLVM Debug]   src1: type=%d\n", instr->src1->type);
    }
    
    switch (instr->opcode) {
        case IR_LOAD_CONST: {
            result = operand_to_llvm_value(backend, instr->src1);
            if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                int temp_id = instr->dest->value.temp_id;
                SemanticType dest_type = instr->dest->data_type;
                            store_to_temp_typed(backend, result, temp_id, dest_type);
            }
            break;
        }
        
        case IR_ASSIGN: {
            LLVMValueRef value = operand_to_llvm_value(backend, instr->src1);
            if (value && instr->dest && instr->dest->type == OPERAND_TEMP) {
                int temp_id = instr->dest->value.temp_id;
                SemanticType dest_type = instr->dest->data_type;
                store_to_temp_typed(backend, value, temp_id, dest_type);
            }
            break;
        }
        
        case IR_ADD: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                // Determine if floating point or integer arithmetic
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                if (dest_type == TYPE_F32 || dest_type == TYPE_F64 || dest_type == TYPE_NUM) {
                    result = LLVMBuildFAdd(backend->builder, lhs, rhs, "fadd");
                } else {
                    result = LLVMBuildAdd(backend->builder, lhs, rhs, "add");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        case IR_SUB: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                if (dest_type == TYPE_F32 || dest_type == TYPE_F64 || dest_type == TYPE_NUM) {
                    result = LLVMBuildFSub(backend->builder, lhs, rhs, "fsub");
                } else {
                    result = LLVMBuildSub(backend->builder, lhs, rhs, "sub");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        case IR_MUL: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                if (dest_type == TYPE_F32 || dest_type == TYPE_F64 || dest_type == TYPE_NUM) {
                    result = LLVMBuildFMul(backend->builder, lhs, rhs, "fmul");
                } else {
                    result = LLVMBuildMul(backend->builder, lhs, rhs, "mul");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        case IR_DIV: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                if (dest_type == TYPE_F32 || dest_type == TYPE_F64 || dest_type == TYPE_NUM) {
                    result = LLVMBuildFDiv(backend->builder, lhs, rhs, "fdiv");
                } else {
                    result = LLVMBuildSDiv(backend->builder, lhs, rhs, "div");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        case IR_MOD: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                if (dest_type == TYPE_F32 || dest_type == TYPE_F64 || dest_type == TYPE_NUM) {
                    result = LLVMBuildFRem(backend->builder, lhs, rhs, "fmod");
                } else {
                    result = LLVMBuildSRem(backend->builder, lhs, rhs, "mod");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        // Comparison operations
        case IR_EQ: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealOEQ, lhs, rhs, "fcmp_eq");
                } else {
                    result = LLVMBuildICmp(backend->builder, LLVMIntEQ, lhs, rhs, "icmp_eq");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                store_to_temp_typed(backend, result, temp_id, dest_type);
                }
            }
            break;
        }
        
        case IR_NEQ: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealONE, lhs, rhs, "fcmp_neq");
                } else {
                    result = LLVMBuildICmp(backend->builder, LLVMIntNE, lhs, rhs, "icmp_neq");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_LT: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealOLT, lhs, rhs, "fcmp_lt");
                } else {
                    // Handle signed vs unsigned
                    if (src_type == TYPE_U8 || src_type == TYPE_U16 || src_type == TYPE_U32 || src_type == TYPE_U64) {
                        result = LLVMBuildICmp(backend->builder, LLVMIntULT, lhs, rhs, "ucmp_lt");
                    } else {
                        result = LLVMBuildICmp(backend->builder, LLVMIntSLT, lhs, rhs, "scmp_lt");
                    }
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_GT: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealOGT, lhs, rhs, "fcmp_gt");
                } else {
                    if (src_type == TYPE_U8 || src_type == TYPE_U16 || src_type == TYPE_U32 || src_type == TYPE_U64) {
                        result = LLVMBuildICmp(backend->builder, LLVMIntUGT, lhs, rhs, "ucmp_gt");
                    } else {
                        result = LLVMBuildICmp(backend->builder, LLVMIntSGT, lhs, rhs, "scmp_gt");
                    }
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_LEQ: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealOLE, lhs, rhs, "fcmp_leq");
                } else {
                    if (src_type == TYPE_U8 || src_type == TYPE_U16 || src_type == TYPE_U32 || src_type == TYPE_U64) {
                        result = LLVMBuildICmp(backend->builder, LLVMIntULE, lhs, rhs, "ucmp_leq");
                    } else {
                        result = LLVMBuildICmp(backend->builder, LLVMIntSLE, lhs, rhs, "scmp_leq");
                    }
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_GEQ: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFCmp(backend->builder, LLVMRealOGE, lhs, rhs, "fcmp_geq");
                } else {
                    if (src_type == TYPE_U8 || src_type == TYPE_U16 || src_type == TYPE_U32 || src_type == TYPE_U64) {
                        result = LLVMBuildICmp(backend->builder, LLVMIntUGE, lhs, rhs, "ucmp_geq");
                    } else {
                        result = LLVMBuildICmp(backend->builder, LLVMIntSGE, lhs, rhs, "scmp_geq");
                    }
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        // Logical operations
        case IR_AND: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                result = LLVMBuildAnd(backend->builder, lhs, rhs, "logical_and");
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_OR: {
            LLVMValueRef lhs = operand_to_llvm_value(backend, instr->src1);
            LLVMValueRef rhs = operand_to_llvm_value(backend, instr->src2);
            
            if (lhs && rhs) {
                result = LLVMBuildOr(backend->builder, lhs, rhs, "logical_or");
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_NOT: {
            LLVMValueRef operand = operand_to_llvm_value(backend, instr->src1);
            
            if (operand) {
                result = LLVMBuildNot(backend->builder, operand, "logical_not");
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_NEG: {
            LLVMValueRef operand = operand_to_llvm_value(backend, instr->src1);
            
            if (operand) {
                SemanticType src_type = instr->src1 ? instr->src1->data_type : TYPE_I32;
                if (src_type == TYPE_F32 || src_type == TYPE_F64 || src_type == TYPE_NUM) {
                    result = LLVMBuildFNeg(backend->builder, operand, "fneg");
                } else {
                    result = LLVMBuildNeg(backend->builder, operand, "neg");
                }
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        // Type conversions
        case IR_INT_TO_FLOAT: {
            LLVMValueRef operand = operand_to_llvm_value(backend, instr->src1);
            
            if (operand) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_F32;
                LLVMTypeRef dest_llvm_type = semantic_type_to_llvm(backend, dest_type);
                
                result = LLVMBuildSIToFP(backend->builder, operand, dest_llvm_type, "int_to_float");
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_FLOAT_TO_INT: {
            LLVMValueRef operand = operand_to_llvm_value(backend, instr->src1);
            
            if (operand) {
                SemanticType dest_type = instr->dest ? instr->dest->data_type : TYPE_I32;
                LLVMTypeRef dest_llvm_type = semantic_type_to_llvm(backend, dest_type);
                
                result = LLVMBuildFPToSI(backend->builder, operand, dest_llvm_type, "float_to_int");
                
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        // Control flow operations
        case IR_LABEL: {
            if (instr->dest && instr->dest->type == OPERAND_LABEL) {
                // Create a new basic block for the label
                LLVMBasicBlockRef label_bb = LLVMAppendBasicBlock(
                    LLVMGetBasicBlockParent(LLVMGetInsertBlock(backend->builder)),
                    instr->dest->value.name
                );
                
                // If current block has no terminator, add branch to label
                if (!LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(backend->builder))) {
                    LLVMBuildBr(backend->builder, label_bb);
                }
                
                LLVMPositionBuilderAtEnd(backend->builder, label_bb);
                printf("[LLVM Debug] Created label: %s\n", instr->dest->value.name);
            }
            break;
        }
        
        case IR_GOTO: {
            if (instr->src1 && instr->src1->type == OPERAND_LABEL) {
                // Find or create target basic block
                LLVMValueRef func = LLVMGetBasicBlockParent(LLVMGetInsertBlock(backend->builder));
                LLVMBasicBlockRef target_bb = NULL;
                
                // Try to find existing block
                LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func);
                while (bb) {
                    const char* bb_name = LLVMGetBasicBlockName(bb);
                    if (bb_name && strcmp(bb_name, instr->src1->value.name) == 0) {
                        target_bb = bb;
                        break;
                    }
                    bb = LLVMGetNextBasicBlock(bb);
                }
                
                // Create if not found
                if (!target_bb) {
                    target_bb = LLVMAppendBasicBlock(func, instr->src1->value.name);
                }
                
                LLVMBuildBr(backend->builder, target_bb);
                printf("[LLVM Debug] Generated goto to: %s\n", instr->src1->value.name);
            }
            break;
        }
        
        case IR_IF_GOTO: {
            if (instr->src1 && instr->src2 && instr->src2->type == OPERAND_LABEL) {
                LLVMValueRef condition = operand_to_llvm_value(backend, instr->src1);
                if (condition) {
                    LLVMValueRef func = LLVMGetBasicBlockParent(LLVMGetInsertBlock(backend->builder));
                    
                    // Find or create target block
                    LLVMBasicBlockRef then_bb = NULL;
                    LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func);
                    while (bb) {
                        const char* bb_name = LLVMGetBasicBlockName(bb);
                        if (bb_name && strcmp(bb_name, instr->src2->value.name) == 0) {
                            then_bb = bb;
                            break;
                        }
                        bb = LLVMGetNextBasicBlock(bb);
                    }
                    if (!then_bb) {
                        then_bb = LLVMAppendBasicBlock(func, instr->src2->value.name);
                    }
                    
                    // Create continuation block
                    LLVMBasicBlockRef cont_bb = LLVMAppendBasicBlock(func, "if_cont");
                    
                    LLVMBuildCondBr(backend->builder, condition, then_bb, cont_bb);
                    LLVMPositionBuilderAtEnd(backend->builder, cont_bb);
                    
                    printf("[LLVM Debug] Generated conditional branch to: %s\n", instr->src2->value.name);
                }
            }
            break;
        }
        
        case IR_IF_FALSE_GOTO: {
            if (instr->src1 && instr->src2 && instr->src2->type == OPERAND_LABEL) {
                LLVMValueRef condition = operand_to_llvm_value(backend, instr->src1);
                if (condition) {
                    LLVMValueRef func = LLVMGetBasicBlockParent(LLVMGetInsertBlock(backend->builder));
                    
                    // Find or create target block
                    LLVMBasicBlockRef else_bb = NULL;
                    LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(func);
                    while (bb) {
                        const char* bb_name = LLVMGetBasicBlockName(bb);
                        if (bb_name && strcmp(bb_name, instr->src2->value.name) == 0) {
                            else_bb = bb;
                            break;
                        }
                        bb = LLVMGetNextBasicBlock(bb);
                    }
                    if (!else_bb) {
                        else_bb = LLVMAppendBasicBlock(func, instr->src2->value.name);
                    }
                    
                    // Create continuation block
                    LLVMBasicBlockRef cont_bb = LLVMAppendBasicBlock(func, "if_false_cont");
                    
                    LLVMBuildCondBr(backend->builder, condition, cont_bb, else_bb);
                    LLVMPositionBuilderAtEnd(backend->builder, cont_bb);
                    
                    printf("[LLVM Debug] Generated conditional branch (false) to: %s\n", instr->src2->value.name);
                }
            }
            break;
        }
        
        case IR_CALL: {
            // Handle function calls
            if (instr->src1 && instr->src1->type == OPERAND_FUNCTION && instr->src1->value.name) {
                const char* func_name = instr->src1->value.name;
                
                if (strcmp(func_name, "print") == 0) {
                    // Handle printf
                    declare_printf(backend);
                    
                    // Build arguments for printf
                    LLVMValueRef args[16];  // Max 16 arguments
                    int arg_count = 0;
                    
                    // Add parameters
                    for (int i = 0; i < instr->param_count && i < 15; i++) {
                        LLVMValueRef arg = operand_to_llvm_value(backend, instr->params[i]);
                        if (arg) {
                            args[arg_count++] = arg;
                        }
                    }
                    
                    if (arg_count > 0) {
                        result = LLVMBuildCall2(backend->builder, 
                                              LLVMGlobalGetValueType(printf_func),
                                              printf_func, args, arg_count, "printf_call");
                    }
                } else if (strcmp(func_name, "scan") == 0) {
                    // Handle scanf
                    declare_scanf(backend);
                    
                    LLVMValueRef args[16];
                    int arg_count = 0;
                    
                    for (int i = 0; i < instr->param_count && i < 15; i++) {
                        LLVMValueRef arg = operand_to_llvm_value(backend, instr->params[i]);
                        if (arg) {
                            args[arg_count++] = arg;
                        }
                    }
                    
                    if (arg_count > 0) {
                        result = LLVMBuildCall2(backend->builder, 
                                              LLVMGlobalGetValueType(scanf_func),
                                              scanf_func, args, arg_count, "scanf_call");
                    }
                } else {
                    // Handle user-defined functions
                    LLVMValueRef func = LLVMGetNamedFunction(backend->module, func_name);
                    if (func) {
                        LLVMValueRef args[16];
                        int arg_count = 0;
                        
                        for (int i = 0; i < instr->param_count && i < 15; i++) {
                            LLVMValueRef arg = operand_to_llvm_value(backend, instr->params[i], 
                                                                   );
                            if (arg) {
                                args[arg_count++] = arg;
                            }
                        }
                        
                        result = LLVMBuildCall2(backend->builder, 
                                              LLVMGlobalGetValueType(func),
                                              func, args, arg_count, "call");
                        
                        printf("[LLVM Debug] Called user function: %s\n", func_name);
                    } else {
                        printf("[LLVM Warning] Function '%s' not declared\n", func_name);
                    }
                }
                
                // Store result if needed
                if (result && instr->dest && instr->dest->type == OPERAND_TEMP) {
                    int temp_id = instr->dest->value.temp_id;
                    SemanticType dest_type = instr->dest->data_type;
                                    store_to_temp_typed(backend, result, temp_id, dest_type);
                    }
                }
            }
            break;
        }
        
        case IR_RETURN: {
            if (instr->src1) {
                LLVMValueRef ret_val = operand_to_llvm_value(backend, instr->src1);
                if (ret_val) {
                    LLVMBuildRet(backend->builder, ret_val);
                }
            } else {
                LLVMBuildRetVoid(backend->builder);
            }
            break;
        }
        
        case IR_STORE_VAR: {
            // Store src2 (value) to src1 (variable name)  
            if (instr->src1 && instr->src1->type == OPERAND_VAR && instr->src2) {
                LLVMValueRef value = operand_to_llvm_value(backend, instr->src2);
                if (value) {
                    LLVMValueRef var_alloca = get_or_create_variable(backend, instr->src1->value.name, instr->src1->data_type);
                    if (var_alloca) {
                        LLVMBuildStore(backend->builder, value, var_alloca);
                        printf("[LLVM Debug] Stored value to variable '%s'\n", instr->src1->value.name);
                    }
                }
            }
            break;
        }
        
        case IR_LOAD_VAR: {
            // Load variable src1 into dest
            if (instr->src1 && instr->src1->type == OPERAND_VAR && instr->dest && instr->dest->type == OPERAND_TEMP) {
                LLVMValueRef var_alloca = get_or_create_variable(backend, instr->src1->value.name, instr->src1->data_type);
                if (var_alloca) {
                    LLVMValueRef loaded_value = LLVMBuildLoad2(backend->builder,
                                                              semantic_type_to_llvm(backend, instr->src1->data_type),
                                                              var_alloca, "var_load");
                    
                    // Store loaded value into destination temp
                    int dest_id = instr->dest->value.temp_id;
                    if (dest_id >= 0 && dest_id < local_var_count) {
                        store_to_temp_typed(backend, loaded_value, dest_id, instr->src1->data_type);
                        printf("[LLVM Debug] Loaded variable '%s' into temp%d\n", instr->src1->value.name, dest_id);
                    }
                }
            }
            break;
        }
        
        default:
            // Handle other instructions as needed
            printf("[LLVM] Unhandled IR instruction: %d\n", instr->opcode);
            break;
    }
}

// Generate LLVM IR from IRProgram with dynamic type-aware system
bool llvm_generate_from_ir(LLVMBackend* backend, IRProgram* program) {
    if (!backend || !program) {
        fprintf(stderr, "Invalid parameters for LLVM generation\n");
        return false;
    }
    
    // Generate functions
    for (IRFunction* func = program->functions; func; func = func->next) {
        // Create function type
        LLVMTypeRef ret_type = semantic_type_to_llvm(backend, func->return_type);
        
        // Create parameter types
        LLVMTypeRef* param_types = NULL;
        if (func->param_count > 0) {
            param_types = malloc(sizeof(LLVMTypeRef) * func->param_count);
            for (int i = 0; i < func->param_count; i++) {
                param_types[i] = semantic_type_to_llvm(backend, func->parameters[i]->data_type);
            }
        }
        
        LLVMTypeRef func_type = LLVMFunctionType(ret_type, param_types, func->param_count, 0);
        LLVMValueRef llvm_func = LLVMAddFunction(backend->module, func->name, func_type);
        
        // Create basic block
        LLVMBasicBlockRef entry = LLVMAppendBasicBlockInContext(backend->context, llvm_func, "entry");
        LLVMPositionBuilderAtEnd(backend->builder, entry);
        
        // Reset temporary table for this function - ensure we have enough capacity
        init_dynamic_tables();
        expand_temp_table(func->temp_counter + 100); // Add safety margin
        
        // Reset all temp allocations for this function
        for (int i = 0; i < temp_capacity; i++) {
            temp_table[i].allocated = false;
            temp_table[i].alloca = NULL;
            temp_table[i].type = TYPE_UNKNOWN;
        }
        
        // Process instructions with type-aware system
        for (IRInstruction* instr = func->instructions; instr; instr = instr->next) {
            translate_ir_instruction(backend, instr);
        }
        
        // Add return if none exists
        if (!LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(backend->builder))) {
            if (func->return_type == TYPE_VOID) {
                LLVMBuildRetVoid(backend->builder);
            } else {
                LLVMValueRef zero = LLVMConstInt(semantic_type_to_llvm(backend, func->return_type), 0, 0);
                LLVMBuildRet(backend->builder, zero);
            }
        }
        
        // Cleanup
        if (param_types) free(param_types);
    }
    
    return true;
}

// Optimize LLVM module
void llvm_optimize(LLVMBackend* backend, int opt_level) {
    if (!backend || opt_level < 0 || opt_level > 3) return;
    
    LLVMPassManagerRef pass_manager = LLVMCreatePassManager();
    
    // Add basic optimization passes
    if (opt_level >= 1) {
        LLVMAddInstructionCombiningPass(pass_manager);
        LLVMAddReassociatePass(pass_manager);
        LLVMAddGVNPass(pass_manager);
        LLVMAddCFGSimplificationPass(pass_manager);
    }
    
    if (opt_level >= 2) {
        LLVMAddDeadStoreEliminationPass(pass_manager);
    }
    
    if (opt_level >= 3) {
        LLVMAddAggressiveDCEPass(pass_manager);
        LLVMAddLoopUnrollPass(pass_manager);
    }
    
    // Run optimizations
    LLVMRunPassManager(pass_manager, backend->module);
    LLVMDisposePassManager(pass_manager);
}

// Emit LLVM IR to file
int llvm_emit_ir(LLVMBackend* backend, const char* filename) {
    if (!backend || !filename) return 0;
    
    char* error = NULL;
    if (LLVMPrintModuleToFile(backend->module, filename, &error)) {
        fprintf(stderr, "Error writing IR to file %s: %s\n", filename, error);
        LLVMDisposeMessage(error);
        return 0;
    }
    
    return 1;
}

// Emit object file using system tools
int llvm_emit_object(LLVMBackend* backend, const char* filename, const char* target_triple) {
    if (!backend || !filename) return 0;
    
    // First emit LLVM IR
    char ir_filename[256];
    snprintf(ir_filename, sizeof(ir_filename), "%s.ll", filename);
    
    if (!llvm_emit_ir(backend, ir_filename)) {
        return 0;
    }
    
    // Use LLC to generate object file
    char command[512];
    if (target_triple) {
        snprintf(command, sizeof(command), 
                "llc -filetype=obj -mtriple=%s %s -o %s", 
                target_triple, ir_filename, filename);
    } else {
        snprintf(command, sizeof(command), 
                "llc -filetype=obj %s -o %s", 
                ir_filename, filename);
    }
    
    int result = system(command);
    
    // Clean up IR file
    unlink(ir_filename);
    
    return (result == 0) ? 1 : 0;
}

// Emit assembly file
bool llvm_emit_assembly(LLVMBackend* backend, const char* filename) {
    if (!backend || !filename) return false;
    
    // First emit LLVM IR
    char ir_filename[256];
    snprintf(ir_filename, sizeof(ir_filename), "%s.ll", filename);
    
    if (!llvm_emit_ir(backend, ir_filename)) {
        return false;
    }
    
    // Use LLC to generate assembly
    char command[512];
    if (backend->target_triple) {
        snprintf(command, sizeof(command), 
                "llc -mtriple=%s %s -o %s", 
                backend->target_triple, ir_filename, filename);
    } else {
        snprintf(command, sizeof(command), 
                "llc %s -o %s", 
                ir_filename, filename);
    }
    
    int result = system(command);
    
    // Clean up IR file
    unlink(ir_filename);
    
    return (result == 0) ? true : false;
}

// Print LLVM module (for debugging)
void llvm_print_module(LLVMBackend* backend) {
    if (!backend) return;
    
    char* ir_string = LLVMPrintModuleToString(backend->module);
    printf("LLVM Module:\n%s\n", ir_string);
    LLVMDisposeMessage(ir_string);
}
