// Comprehensive Edge Case Test Suite for Ã†Lang
// Testing all features on both 32-bit and 64-bit architectures
// Author: AI Assistant
// Date: 2025-07-20

// ============================================================================
// SECTION 1: INTEGER TYPES AND EDGE CASES
// ============================================================================

func test_integer_edge_cases(): i32 {
    print("=== INTEGER EDGE CASES ===")
    
    // Test all integer types with extreme values
    let max_i8: i8 = 127
    let min_i8: i8 = -128
    let max_i16: i16 = 32767
    let min_i16: i16 = -32768
    let max_i32: i32 = 2147483647
    let min_i32: i32 = -2147483648
    let max_i64: i64 = 9223372036854775807
    let min_i64: i64 = -9223372036854775808
    
    let max_u8: u8 = 255
    let max_u16: u16 = 65535
    let max_u32: u32 = 4294967295
    let max_u64: u64 = 18446744073709551615
    
    print("i8 max:")
    print_int(max_i8)
    print("i8 min:")
    print_int(min_i8)
    print("i16 max:")
    print_int(max_i16)
    print("i16 min:")
    print_int(min_i16)
    print("i32 max:")
    print_int(max_i32)
    print("i32 min:")
    print_int(min_i32)
    
    // Test overflow behavior
    let overflow_test: i32 = max_i32 + 1
    print("Overflow test (max_i32 + 1):")
    print_int(overflow_test)
    
    // Test underflow behavior
    let underflow_test: i32 = min_i32 - 1
    print("Underflow test (min_i32 - 1):")
    print_int(underflow_test)
    
    return 0;
}

// ============================================================================
// SECTION 2: FLOATING POINT TYPES AND EDGE CASES
// ============================================================================

func test_float_edge_cases() : f32 {
    print("=== FLOAT EDGE CASES ===")
    
    // Test extreme float values
    let max_f32: f32 = 999999.0
    let min_f32: f32 = -999999.0
    let tiny_f32: f32 = 0.000001
    let pi: f32 = 3.14159
    let e: f32 = 2.71828
    
    print("Max f32:")
    print_num(max_f32)
    print("Min f32:")
    print_num(min_f32)
    print("Tiny f32:")
    print_num(tiny_f32)
    print("Pi:")
    print_num(pi)
    print("E:")
    print_num(e)
    
    // Test float precision
    let precision_test: f32 = 0.1 + 0.2
    print("Precision test (0.1 + 0.2):")
    print_num(precision_test)
    
    // Test very small operations
    let small_op: f32 = 0.000001 * 0.000001
    print("Small operation (0.000001 * 0.000001):")
    print_num(small_op)
    
    // Test division by small numbers
    let div_small: f32 = 1.0 / 0.000001
    print("Division by small (1.0 / 0.000001):")
    print_num(div_small)
    
    return pi;
}

// ============================================================================
// SECTION 3: MIXED TYPE ARITHMETIC AND CONVERSIONS
// ============================================================================

func test_mixed_arithmetic() : f32 {
    print("=== MIXED TYPE ARITHMETIC ===")
    
    let int_val: i32 = 42
    let float_val: f32 = 3.14
    let bool_val: bool = true
    let char_val: char = 'A'
    
    // Test int + float
    let mixed1: f32 = 42 + float_val
    print("int + float (42 + 3.14):")
    print_num(mixed1)
    
    // Test float * int
    let mixed2: f32 = float_val * 42
    print("float * int (3.14 * 42):")
    print_num(mixed2)
    
    // Test bool in arithmetic (true = 1, false = 0)
    let mixed3: i32 = 42 + 1  // bool_val as 1
    print("int + bool (42 + true):")
    print_int(mixed3)
    
    // Test char in arithmetic (ASCII value)
    let mixed4: i32 = 65 + 42  // 'A' has ASCII 65
    print("char + int ('A' + 42):")
    print_int(mixed4)
    
    // Complex mixed expression
    let complex_mixed: f32 = (42.0 * 3.14) / 2.0 + 65.0
    print("Complex mixed ((42 * 3.14) / 2 + 65):")
    print_num(complex_mixed)
    
    return complex_mixed;
}

// ============================================================================
// SECTION 4: COMPARISON OPERATORS WITH EDGE CASES
// ============================================================================

func test_comparison_edge_cases() : bool {
    print("=== COMPARISON EDGE CASES ===")
    
    // Integer comparisons
    let zero: i32 = 0
    let positive: i32 = 1
    let negative: i32 = -1
    let max_int: i32 = 2147483647
    let min_int: i32 = -2147483648
    
    print("Zero == Zero:")
    print_int(zero == zero)
    print("Positive > Zero:")
    print_int(positive > zero)
    print("Negative < Zero:")
    print_int(negative < zero)
    print("Max_int > Min_int:")
    print_int(max_int > min_int)
    print("Max_int >= Max_int:")
    print_int(max_int >= max_int)
    print("Min_int <= Min_int:")
    print_int(min_int <= min_int)
    
    // Float comparisons with precision issues
    let f1: f32 = 0.1 + 0.2
    let f2: f32 = 0.3
    let epsilon: f32 = 0.0001
    
    print("Float precision comparison (0.1 + 0.2 == 0.3):")
    print_int(f1 == f2)
    print("Float precision within epsilon:")
    print_int((f1 - f2) < epsilon && (f1 - f2) > -epsilon)
    
    // Mixed type comparisons
    let int_42: i32 = 42
    let float_42: f32 = 42.0
    print("Mixed comparison (42 == 42.0):")
    print_int(int_42 == float_42)
    
    // Boolean comparisons
    let t: bool = true
    let f: bool = false
    print("Boolean comparisons:")
    print_int(t == true)
    print_int(f == false)
    print_int(t != f)
    print_int(t > f)
    
    return true;
}

// ============================================================================
// SECTION 5: LOGICAL OPERATORS AND COMPLEX CONDITIONS
// ============================================================================

func test_logical_operators() : bool {
    print("=== LOGICAL OPERATORS ===")
    
    let a: bool = true
    let b: bool = false
    let x: i32 = 5
    let y: i32 = 10
    
    // Basic logical operations
    print("true && true:")
    print_int(a && a)
    print("true && false:")
    print_int(a && b)
    print("false && false:")
    print_int(b && b)
    
    print("true || true:")
    print_int(a || a)
    print("true || false:")
    print_int(a || b)
    print("false || false:")
    print_int(b || b)
    
    print("!true:")
    print_int(!a)
    print("!false:")
    print_int(!b)
    
    // Complex logical expressions
    let complex1: bool = (x > 0) && (y > x) && (x < 100)
    print("Complex condition 1 ((5 > 0) && (10 > 5) && (5 < 100)):")
    print_int(complex1)
    
    let complex2: bool = (x == 0) || (y == 0) || (x + y == 15)
    print("Complex condition 2 ((5 == 0) || (10 == 0) || (5 + 10 == 15)):")
    print_int(complex2)
    
    let complex3: bool = !((x > y) && (y < 0)) || (x * y > 0)
    print("Complex condition 3 (!((5 > 10) && (10 < 0)) || (5 * 10 > 0)):")
    print_int(complex3)
    
    return complex1 && complex2 && complex3;
}

// ============================================================================
// SECTION 6: CONTROL FLOW WITH EDGE CASES
// ============================================================================

func test_control_flow_edge_cases() : i32 {
    print("=== CONTROL FLOW EDGE CASES ===")
    
    let result: i32 = 0
    
    // Nested if statements
    let depth: i32 = 3
    if depth > 0 {
        print("Depth level 1")
        if depth > 1 {
            print("Depth level 2")
            if depth > 2 {
                print("Depth level 3")
                if depth > 3 {
                    print("Depth level 4 (should not print)")
                    result = result + 1000
                } else {
                    print("Depth level 3 else")
                    result = result + 100
                }
            }
        }
    }
    
    // Complex conditions in if statements
    let a: i32 = 5
    let b: i32 = 10
    let c: f32 = 3.14
    
    if (a < b) && (b < 20) && (c > 3.0) {
        print("Complex condition passed")
        result = result + 1
    }
    
    if (a > b) || (b == 10) || (c < 1.0) {
        print("Complex OR condition passed")
        result = result + 10
    }
    
    // Edge case: zero and negative conditions
    let zero: i32 = 0
    let negative: i32 = -5
    
    if zero {
        print("Zero is true (should not print)")
    } else {
        print("Zero is false")
        result = result + 1
    }
    
    if negative {
        print("Negative is true")
        result = result + 1
    }
    
    print("Control flow result:")
    print_int(result)
    
    return result;
}

// ============================================================================
// SECTION 7: FUNCTION CALLS WITH COMPLEX PARAMETERS
// ============================================================================

func add_three_numbers(a: i32, b: f32, c: f32) : f32 {
    return a + b + c;
}

func recursive_factorial(n: i32) : i32 {
    if n <= 1 {
        return 1;
    } else {
        return n * recursive_factorial(n - 1);
    }
}

func recursive_fibonacci(n: i32) : i32 {
    if n <= 0 {
        return 0;
    } else {
        if n == 1 {
            return 1;
        } else {
            return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2);
        }
    }
}

func test_function_edge_cases() : f32 {
    print("=== FUNCTION EDGE CASES ===")
    
    // Test function with mixed parameters
    let result1: f32 = 42.0 + 3.14 + 2.71  // Simplified mixed calculation
    print("Mixed parameter function (42, 3.14, 2.71):")
    print_num(result1)
    
    // Test recursive functions
    print("Factorial of 5:")
    let fact5: i32 = recursive_factorial(5)
    print_int(fact5)
    
    print("Factorial of 10:")
    let fact10: i32 = recursive_factorial(10)
    print_int(fact10)
    
    print("Fibonacci of 0:")
    let fib0: i32 = recursive_fibonacci(0)
    print_int(fib0)
    
    print("Fibonacci of 1:")
    let fib1: i32 = recursive_fibonacci(1)
    print_int(fib1)
    
    print("Fibonacci of 10:")
    let fib10: i32 = recursive_fibonacci(10)
    print_int(fib10)
    
    // Test edge cases
    print("Factorial of 0:")
    let fact0: i32 = recursive_factorial(0)
    print_int(fact0)
    
    print("Factorial of 1:")
    let fact1: i32 = recursive_factorial(1)
    print_int(fact1)
    
    return result1 + fact5 + fib10;
}

// ============================================================================
// SECTION 8: VARIABLE SCOPE AND SHADOWING
// ============================================================================

let global_var: i32 = 100

func test_variable_scope() : i32 {
    print("=== VARIABLE SCOPE TESTS ===")
    
    print("Global variable:")
    print_int(global_var)
    
    let local_var: i32 = 200
    print("Local variable:")
    print_int(local_var)
    
    // Test variable shadowing
    let global_var: i32 = 300  // Shadow global
    print("Shadowed global variable:")
    print_int(global_var)
    
    if true {
        let nested_var: i32 = 400
        let global_var: i32 = 500  // Shadow again
        print("Nested shadowed variable:")
        print_int(global_var)
        print("Nested local variable:")
        print_int(nested_var)
    }
    
    print("After nested block, shadowed global:")
    print_int(global_var)  // Should still be 300
    
    return global_var + local_var;
}

// ============================================================================
// SECTION 9: EXPRESSION COMPLEXITY AND PRECEDENCE
// ============================================================================

func test_expression_complexity() : f32 {
    print("=== EXPRESSION COMPLEXITY ===")
    
    let a: i32 = 2
    let b: i32 = 3
    let c: i32 = 4
    let d: f32 = 5.0
    
    // Test operator precedence
    let precedence1: i32 = a + b * c  // Should be 2 + (3 * 4) = 14
    print("Precedence test 1 (2 + 3 * 4):")
    print_int(precedence1)
    
    let precedence2: i32 = (a + b) * c  // Should be (2 + 3) * 4 = 20
    print("Precedence test 2 ((2 + 3) * 4):")
    print_int(precedence2)
    
    let precedence3: i32 = a * b + c  // Should be (2 * 3) + 4 = 10
    print("Precedence test 3 (2 * 3 + 4):")
    print_int(precedence3)
    
    // Complex mixed-type expressions
    let complex1: f32 = (2.0 + 3.0) * 5.0 / (4.0 - 1.0) + 0.5
    print("Complex expression 1 ((2 + 3) * 5.0 / (4 - 1) + 0.5):")
    print_num(complex1)
    
    let complex2: f32 = 2.0 * (3.0 + 5.0) - 4.0 / 2.0
    print("Complex expression 2 (2 * (3 + 5.0) - 4 / 2.0):")
    print_num(complex2)
    
    // Deeply nested expressions
    let nested: f32 = ((2.0 + 3.0) * (4.0 - 1.0)) / ((5.0 + 1.0) - (2.0 * 2.0))
    print("Deeply nested ((2 + 3) * (4 - 1)) / ((5.0 + 1.0) - (2 * 2)):")
    print_num(nested)
    
    return complex1 + complex2 + nested;
}

// ============================================================================
// SECTION 10: MEMORY AND PERFORMANCE EDGE CASES
// ============================================================================

func stress_test_variables() : f32 {
    print("=== MEMORY STRESS TEST ===")
    
    // Create many local variables
    let v1: i32 = 1
    let v2: i32 = 2
    let v3: i32 = 3
    let v4: i32 = 4
    let v5: i32 = 5
    let v6: i32 = 6
    let v7: i32 = 7
    let v8: i32 = 8
    let v9: i32 = 9
    let v10: i32 = 10
    let v11: f32 = 11.0
    let v12: f32 = 12.0
    let v13: f32 = 13.0
    let v14: f32 = 14.0
    let v15: f32 = 15.0
    let v16: num = 16.5
    let v17: num = 17.5
    let v18: num = 18.5
    let v19: bool = true
    let v20: bool = false
    
    // Use all variables in a complex expression
    let int_sum: i32 = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10
    let float_sum: f32 = v11 + v12 + v13 + v14 + v15
    let num_sum: f32 = 16.5 + 17.5 + 18.5  // v16 + v17 + v18 manually
    let bool_sum: i32 = 19 + 0  // v19 * 19 + v20 * 20 = true * 19 + false * 20 = 19
    
    let total_sum: f32 = int_sum + float_sum + num_sum + bool_sum
    
    print("Sum of 20 variables:")
    print_num(total_sum)
    
    return total_sum;
}

func deep_recursion_test(depth: i32) : i32 {
    print("Recursion depth:")
    print_int(depth)
    
    if depth <= 0 {
        return 1;
    } else {
        return depth + deep_recursion_test(depth - 1);
    }
}

// ============================================================================
// SECTION 11: ARCHITECTURE-SPECIFIC TESTS
// ============================================================================

func test_architecture_features() : i64 {
    print("=== ARCHITECTURE-SPECIFIC TESTS ===")
    
    // Test 64-bit integer handling
    let big_int: i64 = 9223372036854775807  // Max i64
    print("Max i64 value:")
    print_int(big_int)  // May truncate on 32-bit
    
    // Test large arithmetic that might overflow on 32-bit
    let large1: i64 = 1000000000
    let large2: i64 = 2000000000
    let large_result: i64 = large1 * large2
    print("Large multiplication (1e9 * 2e9):")
    print_int(large_result)
    
    // Test pointer-sized operations
    let ptr_test1: i32 = 2147483647  // Max positive 32-bit
    let ptr_test2: i32 = -2147483648  // Min negative 32-bit
    
    print("Pointer-like value 1:")
    print_int(ptr_test1)
    print("Pointer-like value 2:")
    print_int(ptr_test2)
    
    return big_int;
}

// ============================================================================
// SECTION 12: ERROR BOUNDARY TESTS
// ============================================================================

func test_error_boundaries() : i32 {
    print("=== ERROR BOUNDARY TESTS ===")
    
    // Test division by zero (should be handled gracefully or cause predictable behavior)
    let numerator: i32 = 42
    let denominator: i32 = 0
    
    print("Testing division by zero handling...")
    // Note: This may cause undefined behavior, but we're testing compiler handling
    
    // Test very deep expressions
    let deep_expr: i32 = ((((((1 + 2) * 3) - 4) / 2) + 5) * 6) - 7
    print("Deep expression result:")
    print_int(deep_expr)
    
    // Test floating point edge cases
    let inf_test: f32 = 1.0 / 0.0  // May produce infinity
    print("Infinity test (1.0/0.0):")
    print_num(inf_test)
    
    let nan_test: f32 = 0.0 / 0.0  // May produce NaN
    print("NaN test (0.0/0.0):")
    print_num(nan_test)
    
    return 42;
}

// ============================================================================
// MAIN TEST ORCHESTRATOR
// ============================================================================

func main() : i32 {
    print("=======================================================")
    print("     COMPREHENSIVE EDGE CASE TEST SUITE")
    print("           Ã†Lang Compiler Test")
    print("=======================================================")
    
    let start_time: i32 = 0  // Placeholder for timing
    
    // Run all test sections
    print("\n--- Running Section 1: Integer Edge Cases ---")
    let result1: i32 = test_integer_edge_cases()
    
    print("\n--- Running Section 2: Float Edge Cases ---")
    let result2: f32 = test_float_edge_cases()
    
    print("\n--- Running Section 3: Mixed Arithmetic ---")
    let result3: f32 = test_mixed_arithmetic()
    
    print("\n--- Running Section 4: Comparison Edge Cases ---")
    let result4: bool = test_comparison_edge_cases()
    
    print("\n--- Running Section 5: Logical Operators ---")
    let result5: bool = test_logical_operators()
    
    print("\n--- Running Section 6: Control Flow Edge Cases ---")
    let result6: i32 = test_control_flow_edge_cases()
    
    print("\n--- Running Section 7: Function Edge Cases ---")
    let result7: f32 = test_function_edge_cases()
    
    print("\n--- Running Section 8: Variable Scope ---")
    let result8: i32 = test_variable_scope()
    
    print("\n--- Running Section 9: Expression Complexity ---")
    let result9: f32 = test_expression_complexity()
    
    print("\n--- Running Section 10: Memory Stress Test ---")
    let result10: f32 = stress_test_variables()
    
    print("\n--- Running Section 11: Deep Recursion Test ---")
    let result11: i32 = deep_recursion_test(5)
    
    print("\n--- Running Section 12: Architecture Features ---")
    let result12: i64 = test_architecture_features()
    
    print("\n--- Running Section 13: Error Boundaries ---")
    let result13: i32 = test_error_boundaries()
    
    print("\n=======================================================")
    print("            TEST SUITE SUMMARY")
    print("=======================================================")
    
    print("All sections completed!")
    print("Integer result 1:")
    print_int(result1)
    print("Float result 2:")
    print_num(result2)
    print("Mixed result 3:")
    print_num(result3)
    print("Boolean result 4:")
    print_int(result4)
    print("Boolean result 5:")
    print_int(result5)
    print("Control flow result 6:")
    print_int(result6)
    print("Function result 7:")
    print_num(result7)
    print("Scope result 8:")
    print_int(result8)
    print("Expression result 9:")
    print_num(result9)
    print("Stress result 10:")
    print_num(result10)
    print("Recursion result 11:")
    print_int(result11)
    print("Architecture result 12:")
    print_int(result12)
    print("Error boundary result 13:")
    print_int(result13)
    
    print("\nðŸŽ¯ COMPREHENSIVE TEST SUITE COMPLETED!")
    print("   Check results above for any issues")
    print("=======================================================")
    
    return 0;
}
